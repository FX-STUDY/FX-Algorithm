# 정렬(Sorting)
4주차에는 정렬(Sorting) 알고리즘에 대해 학습합니다.

## 정렬(Sorting)이란?
**정렬(Sorting)** 알고리즘이란 일정한 기준에 따라 데이터를 순서대로 **오름차순** 혹은 **내림차순**으로 나열하는 것을 의미합니다.

**정렬(Sorting)** 알고리즘에는 여러가지 방법이 존재하는데 그 중 **선택 정렬**, **삽입 정렬**, **퀵 정렬**, **계수 정렬**에 대해 간단히 알아보겠습니다.

## 선택 정렬(Selection Sort)
**선택 정렬(Selection Sort)** 은 **n**개의 데이터가 있을때, 맨 앞에서 부터 원소를 선택 후 **i**번째 원소라고하고 **i + 1**번째 원소부터 **n**번째 원소 중 가장 값이 작은 원소를 선택하여 **i**번째 원소와 스위칭하여 정렬하는 방법을 말합니다.

이렇게 가장 작은 원소를 앞으로 보내는 과정을 계속 반복하다 보면 전체 데이터가 **오름차순** 정렬됩니다. (**내림 차순**의 경우 큰 값을 앞으로 보내도록 반복)

![](https://velog.velcdn.com/images/jeunghun2/post/16c0f56a-028e-4532-abc8-9a381453c514/image.jpeg)

- step 1: 데이터가 아직 정렬되지 않았으므로 가장 첫번째 원소와 첫번째 원소를 제외한 나머지 원소 중 가장 작은 1과 교환한다.
- step 2: 3번째 원소와 5번째 원소 사이에서 2보다 작은 원소가 존재하지 않으므로 교환하지 않는다.
- step 3: 4번째 원소와 5번재 원소 중 가장 작은 3을 선택하여 3번째 원소인 5와 교환한다.

위의 과정을 반복하면 **오름차순** 정렬이 완료됩니다.

### selection_sort.py

```python
arr = [5, 2, 1, 4, 3]

for i in range(len(arr)):
    target = i
    for j in range(i + 1, len(arr)):
        if arr[j] < arr[target]:    # target 보다 작다면 선택
            target = j

    arr[i], arr[target] = arr[target], arr[i]    # swap

print(arr)    # [1, 2, 3, 4, 5]
```

### 선택 정렬의 시간 복잡도
**선택 정렬(Selection Sort)** 의 시간 복잡도는 $O(N^2)$입니다.

## 삽입 정렬(Insertion Sort)
**삽입 정렬(Insersion Sort)** 는 데이터를 적절한 위치에 삽입하는 정렬 방법을 말합니다. 이때, 원소의 적절한 위치에 삽입하기 위해서 해당 원소의 앞에 있는 데이터까지는 이미 정렬이 되어 있다는 가정하에 적절한 위치에 삽입됩니다.

또한 원소의 교환을 위해 특정 범위의 모든 원소를 순회 해야 했던 **선택 정렬**에 비해 **삽입 정렬**은 필요한 때만 위치를 바꾸므로 **선택 정렬**에 비해 시간적으로 장점을 갖습니다.

![](https://velog.velcdn.com/images/jeunghun2/post/8668be4f-c0d3-4c19-9da5-42951d0b3dfc/image.jpeg)

- step 1: 원소 5까지는 정렬이 완료 되어 있다고 가정한다. 원소 2가 원소 5의 왼쪽과 오른쪽 위치 중에 들어갈 위치를 찾아 삽입한다.
- step 2: 원소 1의 앞 원소까지는 정렬이 완료 되었다고 가정한다. 원소 1이 들어갈 위치를 찾아 삽입한다.
- step 3: 원소 4의 앞 원소까지는 정렬이 완료 되었다고 가정합니다. 원소 4가 들어갈 위치를 찾아 삽입한다.

위의 과정을 반복하면 데이터의 정렬이 **오름차순**으로 완료됩니다.

### insertion_sort.py
```python
arr = [5, 2, 1, 4, 3]

for i in range(1, len(arr)):
    for j in range(i, 0, -1):    # 해당 원소로부터 역순으로 진행
        if arr[j] < arr[j -1]:
            arr[j], arr[j - 1] = arr[j - 1], arr[j]
        else:
            break    # 더 이상 작은 원소가 존재하지 않으면 종료

print(arr)    # [1, 2, 3, 4, 5]
```

### 삽입 정렬의 시간 복잡도
일반적인 상황에서 **삽입 정렬**의 시간 복잡도는 $O(N^2)$입니다. 하지만 데이터가 어느 정도 정렬 되어 있다는 가정하에 **최선의 경우** $O(N)$까지 가능하고, 이 시간 복잡도는 아래에 설명 되어 있는 **퀵정렬(Quick Sort)** 의 시간 복잡도보다 더 빠른 성능을 보여 주기 때문에 이미 데이터가 어느 정도 정렬 되어 있는 상황이라면 **삽입 정렬**이 더 효율적인 방법이 될 수 있습니다.

## 퀵 정렬(Quick Sort)
**퀵 정렬(Quick Sort)** 는 이름에서 알 수 있듯 대부분의 일반적인 상황에서 위에서 소개된 정렬 알고리즘보다 더 빠른 성능을 보여주는 정렬 방법입니다.

먼저 **퀵 정렬**은 **분할 정복 기법**을 통해 데이터를 정렬하는 방식입니다.

> **분할 정복(Divide and Conquer)** 는 말 그대로, 어떤 문제를 반 + 반으로 쪼개어 각각을 해결 한 뒤에 다시 하나로 모아서 원래 문제를 해결하는 기법입니다.

이때 데이터를 반으로 쪼개기 위해 기준이 되는 데이터를 **피벗(Pivot)** 이라고 하며, **피벗**을 기준으로 한쪽 반은 **피벗**보다 작은 데이터들로, 한쪽 반은 **피벗**보다 큰 데이터들로 구성되게 하고 분할된 두 부분에 대해 다시 같은 과정을 반복하는 방식입니다.

**피벗**을 설정하고 데이터를 분할하는 방식에는 여러 방식이 존재하는데 그 중 **호어 분할(Hoare Partition)** 방식에 대해 알아봅시다.

![](https://velog.velcdn.com/images/jeunghun2/post/61c5a318-b0ed-43a8-a4dc-471c880c62fe/image.jpeg)

- step 1: 데이터의 리스트 중 첫 번째 원소를 **피벗**으로 설정하고, 왼쪽에서는 **피벗**보다 큰 원소(6)을 찾고, 오른쪽에서는 **피벗**보다 작은 원소(2)를 찾아 두 원소의 위치를 교환한다.
- step 2: step 1의 과정을 반복하다 보면, step 2처럼 찾는 위치가 역전 되는 순간이 발생하게 되는데, 이때 **피벗**과 두 원소(1과 4) 중 더 작은 1을 서로 교환한다.
- step 3: step 2 과정까지 마치게 되면 **피벗**을 기준으로 왼쪽은 **피벗**보다 작은 원소들로, 오른쪽은 **피벗**보다 큰 원소들로 구성되게 된다.

위의 과정을 진행한 뒤에 **피벗** 기준으로 두 영역으로 나누어지게 되고 다시 왼쪽 영역 리스트와 오른쪽 영역 리스트에 대해 위와 같은 과정을 반복하면 데이터가 **오름차순**으로 정렬되게 됩니다. 이 과정은 재귀 호출을 통해 쉽게 구현 가능한데, 그럼 이렇게 영역을 두 부분으로 분할하는 재귀의 과정은 언제까지 진행돼야 하는 걸까요? 바로 나눈 영역의 내부 리스트 개수가 1개일때 정렬이 마무리되게 됩니다.

### quick_sort.py
```python
arr = [3, 6, 1, 4, 2, 5]

def quick_sort(arr, start, end):
    if start >= end:    # 원소가 1개인 경우 종료
        return

    pivot = start
    left = start + 1
    right = end

    while left <= right:
        # pivot보다 큰 데이터를 찾을때까지 반복
        while left <= end and arr[left] <= arr[pivot]:
            left += 1

        # pivot보다 작은 데이터를 찾을때까지 반복
        while right > start and arr[right] >= arr[pivot]:
            right -= 1

        if left > right:
            arr[pivot], arr[right] = arr[right], arr[pivot]
        else:
            arr[left], arr[right] = arr[right], arr[left]

    # 분할 이후 왼쪽 리스트에 대해 정렬
    quick_sort(arr, start, pivot - 1)
    # 분할 이후 오른쪽 리스트에 대해 정렬
    quick_sort(arr, left + 1, end)

quick_sort(arr, 0, len(arr) - 1)
print(arr)    # [1, 2, 3, 4, 5, 6]
```

### 퀵 정렬의 시간 복잡도
**퀵 정렬**의 시간 복잡도는 평균적으로 $O(NlogN)$의 시간 복잡도를 보여주지만, 최악의 경우 $O(N^2)$까지 나올 수 있습니다. 데이터가 무작위로 입력되어 있는 경우 빠르게 정렬을 마칠 수 있지만 반대로 데이터가 어느 정도 정렬 되어 있는 경우에는 속도가 느려질 수 있습니다.

**C++** 의 경우 **퀵 정렬**에 기반한 정렬 라이브러리를 제공해 주는데 어떠한 데이터가 들어 오더라도 동일한 정렬 속도를 보장하기 위해 추가적인 로직을 더하여 최악의 경우에도 $O(NlogN)$의 시간 복잡도를 보장하도록 해줍니다.

추가적으로 **Python**이나 **Java**, **JavaScript** 등의 정렬 라이브러리 같은 경우에도 **quick sort**와 비슷한 시간을 가지는 **merge sort** 기반에 **selection sort**를 추가하여 변형한 **TimSort** 방식을 사용하여 최악의 경우에도 $O(NlogN)$의 시간 복잡도를 보장하도록 설계 되어있습니다.

## 계수 정렬(Count Sort)
**계수 정렬(Count Sort)** 의 경우 **퀵 정렬**으로도 제한된 시간 내에 해결을 할 수 없는 경우 특정 조건을 만족하는 상황에서 **퀵 정렬**보다 더 빠르게 동작할 수 있는 정렬 알고리즘입니다. 이때 '특정 조건을 만족하는 상황'이란 아래와 같습니다.

> 데이터의 크기가 한정되어 정수 형태로 표현할 수 있을때

 데이터의 형태가 무한히 표현 가능한 실수 형태의 경우 **계수 정렬**을 사용하기 어려우며, **계수 정렬**은 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않는 경우에 효과적으로 동작할 수 있습니다.

데이터의 개수를 $N$개, 데이터의 최대 값을 $K$개라고 했을때 **개수 정렬**은 최악의 경우에도 $O(N + K)$, 즉 $O(N)$ (상수 생략) 만큼의 시간 복잡도를 가집니다. **퀵 정렬**과 비교해 보았을때 최악의 경우에도 매우 빠른 속도를 보여주는 것을 알 수 있습니다.

**계수 정렬**의 구현 원리는 다음과 같습니다.

![](https://velog.velcdn.com/images/jeunghun2/post/8e50c76c-bce7-4229-9985-ca518b59bfec/image.jpeg)

- step 1: 0부터 데이터의 최대값까지의 크기의 데이터 개수를 카운팅할 테이블을 생성한다.
- step 2: 앞쪽 데이터부터 확인을 하면서 데이터에 해당하는 카운트에 +1을 한다. 예를 들어 첫번째 데이터인 6부터 6번 인덱스의 카운트에 +1을하고 두번째 데이터인 4번 인덱스의 카운트에 +1을 하는 것과 같이 데이터의 개수를 파악한다.
- step 3: 카운트 테이블을 순회하면서 카운트 개수만큼 데이터를 출력한다. 예를 들어 인덱스 0번은 카운트가 1이므로 0을 1회 출력하고, 인텍스 4번은 카운트가 2이므로 4를 2회 출력한다.

### count_sort.py

```python
arr = [6, 4, 2, 5, 3, 1, 4, 0]
count = [0] * (max(arr) + 1)    # 카운트 테이블

for i in range(len(arr)):
    count[arr[i]] += 1    # 카운트 증가

for i in range(len(count)):
    for j in range(count[i]):    # 카운트 개수만큼 출력
        print(i)

# 0
# 1
# 2
# 3
# 4
# 4
# 5
# 6
```

## 기본 내장 정렬 라이브러리에 대하여
언어별로 제공하는 정렬 라이브러리 (`sort` 함수)는 위에서 언급한 것과 같이 **병합 정렬**(혹은 **퀵 정렬**)의 기반에 **선택 정렬**을 추가한 **하이브리드 방식**의 정렬 방법을 사용하여 최악의 경우에도 $O(NlogN)$의 시간 복잡도를 보여줍니다. 따라서 **퀵 정렬**을 직접 구현하는 것보다 내장 정렬 함수를 사용하는 것이 유리할 수 있으며, 입력 데이터의 크기가 **퀵 정렬**로 제한된 시간 내에 처리할 수 없고 데이터의 범위가 한정적인 경우에는 **계수 정렬**과 같은 방법을 직접 구현하여 해결할 수 있습니다.