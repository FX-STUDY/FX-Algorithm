# 다이나믹 프로그래밍(DP)
6주차에는 **다이나믹 프로그래밍(DP)** 알고리즘에 대해 학습합니다.

## 다이나믹 프로그래밍이란?
**다이나믹 프로그래밍**이란 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 말합니다. **다이나믹 프로그래밍** 알고리즘을 사용할 수 있는 조건은 아래와 같습니다.

- 큰 문제를 작은 문제로 나눌 수 있다.
- 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

위의 조건을 만족하는 문제일때, **메모이제이션(Memoization)** 기법을 사용하여 **다이나믹 프로그래밍** 알고리즘을 구현할 수 있는데, **메모이제이션** 기법은 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기법입니다.

그럼 **메모이제이션** 기법은 어떻게 구현할 수 있을까요? 구현 방법은 간단합니다. 단순히 이전 계산의 결과 값을 저장할 **DP 테이블**을 리스트(혹은 배열)를 통해 저장하기만 하면 됩니다.

**다이나믹 프로그래밍** 알고리즘으로 해결할 수 있는 대표적인 문제 중 **피보나치 수열**을 통해 **다이나믹 프로그래밍**을 좀 더 자세히 알아 보겠습니다.

### 피보나치 수열
**피보나치 수열**은 이전 두 항의 합이 다음 항으로 나타나는 특정이 있는 수열입니다. 예를 들어 아래와 같은 수열이 **피보나치 수열**이라고 할 수 있습니다.

```text
1 1 2 3 5 8 13 21 ...
```

**피보나치 수열**을 인접한 항 사이의 관계식으로 표현할 수 있는 **점화식**의 형태로 나타내면 다음과 같이 표현할 수 있습니다.

> $a_{n}$ = $a_{n - 1}$ + $a_{n - 2}$, $a_{1}$ = 1, $a_{2} = 1$

위의 점화식을 해석하면 $n$번째 항의 값은 $n - 1$번째 항의 값과 $n - 2$번째 항의 합과 같다. 단, 1번째와 2번째 항의 값은 1과 같다.

## 다이나믹 프로그래밍 구현

**피보나치 수열**은 두 가지 방식으로 구현이 가능한데 첫번째는 **탑 다운(top-down)** 방식과 두번째는 **보텀 업(bottom-up)** 방식으로 구현 가능합니다. **탑 다운** 방식은 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식이고, **보텀 업** 방식은 작은 문제부터 차근차근 해결하여  해결하는 방식을 말합니다.

먼저 **탑 다운(top-down)** 방식을 사용하여 **피보나치 수열**의 99번째 항을 구해 볼건데, **탑 다운** 방식은 **재귀(recursion)** 를 통해 구현할 수 있습니다.

```python
# 메모이제이션을 위한 DP 테이블
dp = [0] * 100

def fibonacci(n):
    if n == 1 or n == 2:
        return 1

    # 이미 계산한 이력이 있는 문제라면 그대로 반환
    if dp[n] != 0:
        return dp[n]

    dp[n] = fibonacci(n - 1) + fibonacci(n - 2)
    return dp[n]


print(fibonacci(99))  # 218922995834555169026
```

다음으로 **보텀 업(bottom-up)** 방식으로 99번째 항을 계산해 볼건데, **보텀 업** 방식의 경우 단순 **반복문**을 통해 구현이 가능합니다.

```python
# 메모이제이션을 위한 DP 테이블
dp = [0] * 100

dp[1], dp[2] = 1, 1
n = 99

for i in range(3, n + 1):
    dp[i] = dp[i - 1] + dp[i - 2]

print(dp[99])    # 218922995834555169026
```

## 다이나믹 프로그래밍의 시간복잡도
**다이나믹 프로그래밍** 알고리즘의 **시간 복잡도**는 이전의 계산 결과를 다시 다음 문제에 사용되어 추가적인 연산이 필요 없어진다는 점에서 $O(N)$의 **시간 복잡도**를 가집니다. 