# 최단 경로(Shortest Path) 알고리즘
7주차에는 **최단 경로** 알고리즘, 그 중에서도 **다익스트라(Dijkstra)** 알고리즘에 대해 학습합니다.

## 다익스트라(Dijkstra) 알고리즘
**다익스트라(Dijkstra)** 알고리즘은 그래프에서 특정 **노드**를 출발하여 다른 **노드**로 가는 각각의 최단 경로를 구해주는 알고리즘입니다.

**다익스트라** 알고리즘은 **그리디** 알고리즘의 일종입니다. 매번 각 노드에 대한 최단 거리 정보를 1차원 리스트에 저장하고 주변 간선을 탐색 하다가 더 짧은 경로를 발견하게 되면 최단 경로를 업데이트해 주는 방식으로 최단 경로를 구할 수 있습니다.

가령 다음과 같은 **그래프**가 있다고 가정해 보겠습니다.
![](https://velog.velcdn.com/images/jeunghun2/post/56c77135-865f-4216-b1c9-54bd063e4500/image.png)


이때 시작 노드는 1번 노드이며, **다익스트라** 알고리즘을 통해 1번 노드를 시작으로 각 노드에 도달하기 위한 **최단 거리**를 구하는 원리를 알아보겠습니다. 참고로 아래의 그림에서 아직 방문하지 않은 노드는 하얀색으로, 현재 방문 중인 노드와 간선은 파란색으로, 방문이 끝난 노드와 간선은 각각 회색과 점선으로 표시하였습니다.

이때 각 노드에 도달하기 위한 **최단 거리**를 1차원 리스트에 저장하고 추후에 더 짧은 거리를 발견하게 된다면 업데이트하게 됩니다. 초기에는 임의의 양의 무한대 값으로 초기화 합니다. 다만, 출발 노드인 1번 노드에서 1번 노드로 향하는 거리는 `0`으로 초기화합니다.

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|무한|무한|무한|무한|

### 1단계

먼저 1번 노드를 방문 처리하고 1번 노드를 거처 다른 노드로 가는 비용을 계산합니다. 1번 노드를 통해 인접한 2번, 3번, 5번 노드에 도달할 수 있고 그 비용은 각각 `1(0 + 1)`, `2(0 + 2)`, `5(0 + 5)`입니다. 현재 최단 거리 리스트에는 2번, 3번, 5번 노드까지의 최단 거리가 **무한**으로 되어 있는데 더 짧은 거리를 발견하였으므로 해당 값으로 업데이트합니다.

![](https://velog.velcdn.com/images/jeunghun2/post/17990514-48da-4e58-875f-e0ccb5e23d91/image.png)

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|1|2|무한|5|

### 2단계

다음으로 지금까지 방문하지 않은 노드 중 거리가 가장 가까운 노드인 2번 노드를 방문합니다. 참고로 가장 가까운 거리인 노드가 여러개라면, 번호가 더 작은 노드를 선택합니다.<br>
2번 노드를 거쳐 방문할 수 있는 노드는 2번 노드와 인접한 3번, 5번 노드입니다. 이때 각 노드에 도달하기 위한 최단 거리는 각각 `4(1 + 3)`, `4(1 + 3)`입니다. 이때 5번 노드는 최단 거리 리스트에 기록된 `5`보다 더 짧은 거리를 찾았으므로 5번 노드의 최단 거리를 `4`로 업데이트합니다.

![](https://velog.velcdn.com/images/jeunghun2/post/d5dfa97c-0081-4040-91e8-a2aa92f4aa1f/image.png)

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|1|2|무한|4|

### 3단계
다음으로 지금까지 방문하지 않은 노드 중 거리가 가장 가까운 노드인 3번 노드를 방문합니다. 3번 노드를 거쳐 방문할 수 있는 노드는 2번 노드와 인접한 4번 노드입니다. 이때 4번 노드까지의 거리는 `3(2 + 1)`으로 최단 거리 리스트에 기록된 무한 보다 더 짧은 거리를 찾았으므로 4번 노드의 최단 거리를 `3`으로 업데이트합니다.

![](https://velog.velcdn.com/images/jeunghun2/post/c4919c98-dbde-4c77-98da-de85d9c80cf1/image.png)

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|1|2|3|4|

### 4단계
4번 노드에 대해서도 동일한 과정을 반복합니다. 4번 노드에서 5번 노드로 가는 거리는 `5(3 + 2)`로 최단 거리 리스트에 기록 되어 있는 값보다 크므로 값을 업데이트 하지 않습니다.

![](https://velog.velcdn.com/images/jeunghun2/post/19cee97b-ef2c-4704-bbed-a6134b103960/image.png)

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|1|2|3|4|

### 5단계
5번 노드에 대해서도 동일한 과정을 반복합니다.

![](https://velog.velcdn.com/images/jeunghun2/post/e75c0d39-cd25-4f20-8005-943f9b55137a/image.png)

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|1|2|3|4|

## 다익스트라 알고리즘 구현

```python
# n: 노드의 개수, m: 간선의 개수
n, m = map(int, input().split())
# 시작 노드
start = int(input())
# graph 연결 정보
graph = [[] for _ in range(n + 1)]
# 방문 여부
visited = [False] * (n + 1)
# 임의의 큰 수
INF = 999999999
# 방문하고자 하는 노드까지의 최단 경로를 저장하기 위한 리스트
distance = [INF] * (n + 1)

# 간선 정보 입력 받기
for _ in range(m):
    from_node, to_node, length = map(int, input().split())
    graph[from_node].append([to_node, length])

# 방문하지 않은 노드 중, 최단 거리가 가장 짧은 노드의 번호 반환
def get_smallest_node():
    min_value = INF
    idx = 0    # 노드 번호
    for i in range(1, n + 1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            idx = i

    return idx

def dijkstra(start):
    # 시작 노드는 최단 거리 0
    distance[start] = 0
    visited[start] = True
    for j in graph[start]:
        distance[j[0]] = j[1]

    # 시작 노드를 제외한 n - 1개의 노드에 대해 반복 수행
    for i in range(n - 1):
        now = get_smallest_node()
        visited[now] = True

        # 현재 노드와 연결된 다른 노드 간의 거리 확인
        for j in graph[now]:
            cost = distance[now] + j[1]
            # 만약 노드 간의 거리가 더 짧다면 최단 거리 업데이트
            if cost < distance[j[0]]:
                distance[j[0]] = cost

dijkstra(start)

# INPUT
# 5 8
# 1
# 1 2 1
# 1 3 2
# 2 3 3
# 2 5 3
# 3 4 1
# 4 5 2
# 1 5 5
# 5 2 3

for i in range(1, n + 1):
    # 노드에 도달할 수 없는 경우
    if distance[i] == INF:
        print("INFINITY")
    # 노드까지의 최단 경로
    else:
        print(distance[i])

# OUTPUT
# 0
# 1
# 2
# 3
# 4
```

## 다익스트라 알고리즘 시간 복잡도
그래프 노드의 개수를 $V$라고 할때, 방문하지 않은 노드 중에서 발견한 경로가 가장 짧은 노드를 찾기 위해 **순차 탐색**을 실시 한다는 점에서 위에서 소개된 **다익스트라** 알고리즘의 시간 복잡도는 $O(V^2)$입니다.

## 개선된 다익스트라 알고리즘
$O(V^2)$의 시간 복잡도는 데이터의 개수가 많아진다면 사용하기 힘들 수 있습니다. 이번에는 시간 복잡도를 개선한 **다익스트라** 알고리즘에 대해 알아 보겠습니다.

시간 복잡도를 줄이기 위해서는 **순차 탐색**에서 발생하는 연산량을 줄여 시간 복잡도를 개선할 수 있습니다. 방문하지 않은 노드 중 거리가 가장 짧은 노드를 찾는다는 아이디어를 구현하기 위해서 **우선순위 큐(Priority Queue)** 자료구조를 사용할 수 있습니다. 즉, 위에서 구현한 **다익스트라 알고리즘**에서 `get_smallest_node()` 함수를 **우선순위 큐**로 대체할 수 있다는 말과 같습니다. 그 이외의 알고리즘은 동일합니다.

위에서와 마찬가지로 시작 노드인 1번 노드의 거리는 0으로 나머지 노드까지의 거리는 무한으로 초기화 합니다. 그리고 시작 노드를 **우선순위 큐**에 넣습니다. 이때 튜플을 **우선순위 큐**에 넣는데 (거리, 노드)의 형태로 집어 넣겠습니다.

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|무한|무한|무한|무한|

|||
|:---:|:---:|
|우선 순위 큐|(0, 1)|

### 1단계

**우선순위 큐**에서 가장 짧은 거리의 노드인 1번 노드를 꺼내 옵니다. 1번 노드를 거쳐 도달할 수 있는 노드는 2번, 3번, 5번 노드로 1번 노드까지의 거리가 0이므로 각 노드에 도달할 수 있는 거리는 각각 `1(0 + 1)`, `2(0 + 2)`, `5(0 + 5)`이고 현재 각 노드에 저장 되어있는 거리는 무한이므로 세 노드의 거리를 모두 업데이트 해줍니다. 그리도 업데이트한 세 노드에 대해 다시 **우선순위 큐**에 넣어줍니다.

![](https://velog.velcdn.com/images/jeunghun2/post/17990514-48da-4e58-875f-e0ccb5e23d91/image.png)

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|1|2|무한|5|

|||
|:---:|:---:|
|우선 순위 큐|(1, 2), (2, 3), (5, 5)|

### 2단계

이어서 **우선순위 큐**에서 원소를 하나 꺼내 같은 동작을 반복합니다. 다음으로 거리가 가까운 노드는 2번 노드로 2번 노드를 거쳐 도달할 수 있는 노드는 3번 노드와 5번 노드로 2번 노드까지의 거리가 1이므로 각 노드까지의 도달할 수 있는 거리는 각각 `4(1 + 3)`, `4(1 + 3)`입니다. 이때, 3번 노드까지의 거리(4)는 이전에 구해둔 거리(2)보다 짧지 않으므로 거리를 업데이트 하지 않으며, **우선순위 큐**에도 넣지 않습니다. 5번 노드의 경우 5번 노드까지의 거리(4)가 이전에 구해둔 거리(5)보다 짧으므로 거리를 업데이트하고 5번 노드를 **우선순위 큐**에 넣습니다.

![](https://velog.velcdn.com/images/jeunghun2/post/d5dfa97c-0081-4040-91e8-a2aa92f4aa1f/image.png)

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|1|2|무한|4|

|||
|:---:|:---:|
|우선 순위 큐|(2, 3), (4, 5), (5, 5)|

### 3단계
**우선순위 큐**에서 원소를 하나 꺼내서 3번 노드에 대해 처리합니다. 3번 노드를 거쳐 4번 노드에 도달할 수 있으므로 거리를 무한에서 `3(2 + 1)`로 업데이트하고 **우선순위 큐**에 해당 노드를 넣어줍니다.

![](https://velog.velcdn.com/images/jeunghun2/post/c4919c98-dbde-4c77-98da-de85d9c80cf1/image.png)

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|1|2|3|4|

|||
|:---:|:---:|
|우선 순위 큐|(3, 4), (4, 5), (5, 5)|

### 4단계
마찬가지로 **우선순위 큐**에서 원소를 하나 꺼내서 4번 노드에 대해서 수행합니다. 4번 노드를 거쳐 5번 노드에 도달할 수 있고 그 길이는 `5(3 + 2)`이지만 기록되어 있는 거리 `4`보다 짧지 않으므로 거리를 업데이트하지 않고 **우선순위 큐**에도 넣지 않습니다.

![](https://velog.velcdn.com/images/jeunghun2/post/19cee97b-ef2c-4704-bbed-a6134b103960/image.png)

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|1|2|3|4|

|||
|:---:|:---:|
|우선 순위 큐|(4, 5), (5, 5)|

### 5단계

**우선순위 큐**에서 원소를 꺼내어 동일한 방법으로 처리합니다. 이때 더 이상 5번 노드를 거쳐 도달할 수 있는 노드의 최단 거리를 업데이트할 수 없으므로 **우선순위 큐**에 값을 넣지 않습니다.

![](https://velog.velcdn.com/images/jeunghun2/post/e75c0d39-cd25-4f20-8005-943f9b55137a/image.png)

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|1|2|3|4|

|||
|:---:|:---:|
|우선 순위 큐|(5, 5)|

### 6단계
마지막에 남아 있는 원소를 꺼냅니다. 5번 노드는 이미 방문 처리된 노드이므로 확인할 필요 없이 무시합니다.

|노드 번호|1|2|3|4|5|
|------|:---:|:---:|:---:|:---:|:---:|
|거리|0|1|2|3|4|

|||
|:---:|:---:|
|우선 순위 큐||

## 우선순위 큐를 이용한 다익스트라 알고리즘 구현
```python
import heapq

# n: 노드의 개수, m: 간선의 개수
n, m = map(int, input().split())
# 시작 노드
start = int(input())
# graph 연결 정보
graph = [[] for _ in range(n + 1)]
# 방문 여부
visited = [False] * (n + 1)
# 임의의 큰 수
INF = 999999999
# 방문하고자 하는 노드까지의 최단 경로를 저장하기 위한 리스트
distance = [INF] * (n + 1)

# 간선 정보 입력 받기
for _ in range(m):
    from_node, to_node, length = map(int, input().split())
    graph[from_node].append([to_node, length])

def dijkstra(start):
    queue = []
    # 시작 노드를 큐에 삽입
    heapq.heappush(queue, (0, start))
    distance[start] = 0

    # 큐가 비어있지 않는 동안 실행
    while queue:
        # 가장 짧은 거리를 가진 노드 꺼내기
        dis, now = heapq.heappop(queue)

        # 이미 처리된 노드는 무시
        if distance[now] < dis:
            continue
        # 인접한 다른 노드 확인
        for i in graph[now]:
            cost = dis + i[1]
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(queue, (cost, i[0]))

dijkstra(start)

# INPUT
# 5 8
# 1
# 1 2 1
# 1 3 2
# 2 3 3
# 2 5 3
# 3 4 1
# 4 5 2
# 1 5 5
# 5 2 3

for i in range(1, n + 1):
    # 노드에 도달할 수 없는 경우
    if distance[i] == INF:
        print("INFINITY")
    # 노드까지의 최단 경로
    else:
        print(distance[i])

# OUTPUT
# 0
# 1
# 2
# 3
# 4
```

## 우선순위 큐를 이용한 다익스트라 알고리즘의 시간 복잡도
먼저 **우선순위 큐**에 데이터를 넣었다 빼는데 걸리는 시간 복잡도는 $O(NlogN)$의 시간 복잡도를 가집니다. 또한 하나의 노드에 대해 연결된 모든 간선을 확인하기 때문에 간선의 개수 $E$만큼 연산이 수행되기 되어 시간  복잡도는 $O(ElogE)$라고 할 수 있으며, 모든 노드 끼리 서로 연결 되어 있을때 간선의 개수를 $V^2$개라고 할 수 있고 따라서 최악의 경우에도 $O(ElogV^2)$ 즉, 우선순위 큐를 이용한 다익스트라 알고리즘의 시간 복잡도는 $O(ElogV)$라고 할 수 있습니다.