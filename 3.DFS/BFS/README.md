# DFS / BFS
3주차에는 **그래프 탐색**에 대해 학습합니다.

## 그래프 탐색이란?
어떤 한 **그래프**와 해당 그래프의 **시작 정점(시작 노드)** 이 주어졌을때, 시작점에서 **간선** 을 타고 이동할 수 있는 **정점(노드)** 들을 모두 찾아야 하는 문제를 의미합니다.

![](https://velog.velcdn.com/images/jeunghun2/post/c355c2ba-6552-42b9-a0e3-9bd42d306905/image.png)

추가적으로 두 노드가 간선으로 연결 되어 있으면 이것을 '두 노드는 인접하다'라고 표현합니다.

이번 주차에는 그래프 탐색 알고리즘 중 **DFS** 알고리즘과 **BFS** 알고리즘에 대해 알아 보겠습니다.

## DFS
**DFS**는 **Depth-First-Search**의 약자로 **깊이 우선 탐색**이라고 부르며, 그래프의 깊은 부분부터 탐색하는 알고리즘을 말합니다. 다시 말해, 시작 노드에서 시작해서 특정 경로(보통 왼쪽 노드부터)의 그래프 가장 깊숙히 들어 갔다가 더 이상 방문하지 않은 노드가 없을 때, 시작 노드로 돌아와 다음 경로를 탐색하는 알고리즘을 말합니다.

**DFS**는 **Stack(스택)** 자료구조를 이용하여 구현할 수 있습니다.

**DFS**가 그래프를 탐색하는 순서는 다음과 같습니다.

1. 탐색 시작 노드를 스택에 넣고 방문 처리한다.
2. 스택의 최상단의 노드로부터 방문하지 않은 인접 노드가 있다면 그 노드를 스택에 넣고 방문 처리를 한다.
3. 만약 더 이상 방문하지 않은 노드가 없다면 최상단의 노드를 스택으로부터 꺼낸다.
4. 위의 과정을 스택에 요소가 존재하지 않을때까지 반복한다.

> 여기서 **방문 처리**란 그래프를 탐색하면서 한번 탐색한 노드를 중복 탐색을 방지하기 위해 체크하는 것을 의미 합니다.

가령, 다음과 같은 그래프가 있다고 가정해 봅시다.

![](https://velog.velcdn.com/images/jeunghun2/post/b01ed48c-3967-400c-a7f3-affe53c7c8b9/image.png)

이 그래프를 DFS 알고리즘으로 탐색하는 방법은 다음과 같습니다. (편의상 방문 완료한 노드는 검은색 노드로 표현 하였습니다.)

![](https://velog.velcdn.com/images/jeunghun2/post/d08232c8-e192-4e8a-a7e9-93735bd9319f/image.png)

- 1단계: 1번 노드를 시작으로 방문 처리 후 스택에 삽입한다.
- 2단계: 스택의 최상단 노드인 1번 노드로부터 인접한 노드중 방문하지 않은 2번, 3번 노드 중 가장 작은 노드부터 방문처리 후 스택에 삽입한다.

![](https://velog.velcdn.com/images/jeunghun2/post/4030c116-d2ba-4a5b-887d-ebc6ee770c38/image.png)

- 3단계: 최상단 노드인 2번 노드로부터 인접한 1번, 4번, 5번 노드중 방문하지 않은 가장 작은 노드인 4번 노드를 방문 처리 후 스택에 삽입한다.
- 4단계: 최상단 노드인 4번 노드로부터 인접한 2번 , 4번 노드 중 방문하지 않은 5번 노드를 방문 처리 후 스택에 삽입한다.

![](https://velog.velcdn.com/images/jeunghun2/post/220bb236-1509-422e-a6bc-12cc1ef19545/image.png)

- 5단계: 최상단 노드인 5번 노드의 인접한 노드 중에는 더 이상 방문하지 않은 노드가 존재하지 않는다. 따라서 5번 노드를 스택에서 삭제한다.
- 6단계: 그 다음 최상단 노드인 4번, 2번 노드도 마찬가지로 인접한 노드 중 방문하지 않은 노드가 없으므로 스택에서 삭제한다.

![](https://velog.velcdn.com/images/jeunghun2/post/8f46f92c-fa6a-45e6-926e-166ab17d03b8/image.png)

- 7단계: 최상단 노드인 1번 노드로 돌아와 인접한 2번, 3번 노드중 방문하지 않은 3번 노드를 방문처리하고 스택에 삽입한다.
- 8단계: 최상단 노드인 3번노드와 인접한 1번, 6번 노드중 방문하지 않은 6번 노드를 방문처리 후 스택에 삽입한다.

![](https://velog.velcdn.com/images/jeunghun2/post/adb9f201-af3a-43ba-930b-e0b266c907d5/image.png)

- 9단계: 최상단 노드에서 더 이상 방문하지 않은 노드가 없다면 스택에서 삭제한다.

최종 결과 **DFS** 위의 그래프를 탐색하는 경우 1번 -> 2번 -> 4번 -> 5번 -> 3번 -> 6번 노드 순서대로 탐색할 수 있습니다.

## 코드로 DFS 구현하기

위와 같이 **스택**에 데이터를 삽입하고 삭제하는 과정은 **재귀 함수**를 통해 구현이 가능하며, 데이터의 개수가 N개 일때, **그래프**의 모든 노드를 탐색 하는데 $O(N)$의 **시간 복잡도**를 가집니다.

아래는 **DFS**를 구현한 코드이며 **그래프**의 연결 형태를 **인접 리스트** 방식의 2차원 리스트로 표현 하였는데 그 의미는 다음과 같습니다.

```python
# 그래프를 2차원 리스트로 표현
graph = [
    [],
    [2, 3],    # 1번 노드는 2, 3번 노드와 연결
    [1, 4, 5],    # 2번 노드는 1, 4, 5번 노드와 연결
    [1, 6],    # 3번 노드는 1, 6번 노드와 연결
    [2, 5],    # 4번 노드는 2, 5번 노드와 연결
    [2, 4],    # 5번 노드는 2, 4번 노드와 연결
    [3]    # 6번 노드는 3번 노드와 연결
]
```

## dfs.py
```python
def dfs(graph, v, visited):
    visited[v] = True
    print(v, end=" ")
    for i in graph[v]:
        if not visited[i]:	# 인접한 노드 중 방문하지 않은 노드가 있다면 재귀 함수를 호출하여 방문처리
            dfs(graph, i, visited)


graph = [	# 그래프를 2차원 리스트로 표현
    [],
    [2, 3],
    [1, 4, 5],
    [1, 6],
    [2, 5],
    [2, 4],
    [3]
]

visited = [False] * 7    # 방문 처리를 위한 리스트

dfs(graph, 1, visited)
```

## BFS
**BFS**는 **Breadth-First-Search**의 약자로 **너비 우선 탐색**이라고 하며, 그래프의 노드와 연결된 가장 가까운 노드를 먼저 탐색하는 알고리즘입니다.

**BFS** 알고리즘은 **큐(Queue)** 자료구조를 이용하여 구현 가능하며 그 과정은 다음과 같습니다.

1. 탐색 시작 노드를 큐에 넣고 방문 처리한다.
2. 큐에서 가장 먼저 들어온 노드를 꺼내고 해당 노드의 인접한 노드 중 방문하지 않은 노드를 모두 큐에 넣고 방문 처리한다.
3. 큐에 노드가 남아 있지 않을 때까지 반복한다.

위에서 **DFS**를 설명할때 사용한 그래프를 통해 **BFS**를 구현하는 방법을 살펴 봅시다.

![](https://velog.velcdn.com/images/jeunghun2/post/f6a64ae9-05ba-4e4e-beeb-6a40f10ee462/image.png)

- 1단계: 시작 노드를 큐에 삽입 후 방문 처리한다.
- 2단계: 먼저 들어온 1번 노드를 큐에서 삭제하고 1번 노드와 인접한 노드 중 방문하지 않은 2번, 3번 노드를 모두 큐에 삽입한다.

![](https://velog.velcdn.com/images/jeunghun2/post/bfd864bc-e30c-4d9a-968b-1931a5df9d82/image.png)

- 3단계: 다음으로 먼저 들어온 2번 노드를 규에서 삭제하고 2번 노드와 인접한 노드 중 방문 처리를 하지 않은 노드를 모두 큐에 삽입한다.
- 4단계: 그 다음으로 먼저 들어온 3번 노드를 큐에서 삭제하고 3번 노드와 인접한 노드 중 방문 처리를 하지 않은 노드를 모두 큐에 삽입한다.

![](https://velog.velcdn.com/images/jeunghun2/post/d271ad85-9c91-40c9-81d9-a8ac479bc730/image.png)

- 5단계: 다음으로 먼저 들어온 4번 노드를 삭제한다. 4번 노드와 인접한 노드는 모두 방문 처리 되었다. 따라서 노드를 삽입하는 과정은 무시한다.

## BFS 코드 구현
**BFS**도 **DFS**와 마찬가지로 데이터의 개수가 N개 일때, **그래프**의 모든 노드를 탐색 하는데 $O(N)$의 **시간 복잡도**를 가집니다.

다만 **DFS**를 **재귀 함수**로 구현하는 경우 **Stack Overflow**가 발생할 수 있기에 **BFS**가 **DFS** 비해 시간적으로 더 우위를 가집니다.

## bfs.py

```python
from collections import deque


def bfs(graph, start, visited):
    queue = deque([start])
    visited[start] = True   # 시작 노드 방문처리
    while queue:
        v = queue.popleft()
        print(v, end=" ")
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True


graph = [
    [],
    [2, 3],
    [1, 4, 5],
    [1, 6],
    [2, 5],
    [2, 4],
    [3]
]

visited = [False] * 7

bfs(graph, 1, visited)      # 1 2 3 4 5 6
```